% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmcmc_control.R
\name{pmcmc_control}
\alias{pmcmc_control}
\title{Control for the pmcmc}
\usage{
pmcmc_control(
  n_steps,
  n_chains = 1L,
  n_threads_total = NULL,
  n_workers = 1L,
  rerun_every = Inf,
  rerun_random = FALSE,
  use_parallel_seed = FALSE,
  save_state = TRUE,
  save_restart = NULL,
  save_trajectories = FALSE,
  progress = FALSE,
  nested_step_ratio = 1,
  nested_update_both = FALSE,
  filter_early_exit = FALSE,
  restart_match = FALSE,
  n_burnin = NULL,
  n_steps_retain = NULL,
  adaptive_proposal = NULL,
  path = NULL
)
}
\arguments{
\item{n_steps}{Number of MCMC steps to run. This is the only
required argument.}

\item{n_chains}{Optional integer, indicating the number of chains
to run. If more than one then we run a series of chains and
merge them with \code{\link[=pmcmc_combine]{pmcmc_combine()}}. Chains are run in series,
with the same filter if \code{n_workers} is 1, or run in parallel
otherwise.}

\item{n_threads_total}{The total number of threads (i.e., cores)
the total number of threads/cores to use. If \code{n_workers} is
greater than 1 then these threads will be divided evenly across
your workers at first and so \code{n_threads_total} must be an even
multiple of \code{n_workers}.  If \code{n_chains} is not a clean multiple
of \code{n_workers} we will try and allocate the leftover threads
evenly across the last wave of chains.  This value must be
provided if \code{n_workers} is given, but is optional otherwise - if
given it overrides the value in the particle filter.}

\item{n_workers}{Number of "worker" processes to use to run chains
in parallel. This must be at most \code{n_chains} and is recommended
to be a divisor of \code{n_chains}. If \code{n_workers} is 1, then chains
are run in series (i.e., one chain after the other). See the
parallel vignette (\code{vignette("parallelisation", package = "mcstate")}) for more details about this approach.}

\item{rerun_every}{Optional integer giving the frequency at which
we should rerun the particle filter on the current "accepted"
state.  The default for this (\code{Inf}) will never rerun this
point, but if you set to 100, then every 100 steps we run the
particle filter on both the proposed \emph{and} previously accepted
point before doing the comparison.  This may help "unstick"
chains, at the cost of some bias in the results.}

\item{rerun_random}{Logical, controlling the behaviour of
rerunning (when \code{rerun_every} is finite). The default value of
\code{FALSE} will rerun the filter deterministically at a fixed
number of iterations (given by \code{rerun_every}). If \code{TRUE}, then
we stochastically rerun each step with probability of \code{1 / rerun_every}. This gives the same expected number of MCMC steps
between reruns but a different pattern.}

\item{use_parallel_seed}{Logical, indicating if seeds should be
configured in the same way as when running workers in parallel
(with \code{n_workers > 1}).  Set this to \code{TRUE} to ensure
reproducibility if you use this option sometimes (but not
always). This option only has an effect if \code{n_workers} is 1.}

\item{save_state}{Logical, indicating if the state should be saved
at the end of the simulation. If \code{TRUE}, then a single
randomly selected particle's state will be collected at the end
of each MCMC step. This is the full state (i.e., unaffected by
and \code{index} used in the particle filter) so that the
process may be restarted from this point for projections.  If
\code{save_trajectories} is \code{TRUE} the same particle will
be selected for each. The default is \code{TRUE}, which will
cause \code{n_state} * \code{n_steps} of data to be output
alongside your results. Set this argument to \code{FALSE} to
save space, or use \code{\link[=pmcmc_thin]{pmcmc_thin()}} after running the
MCMC.}

\item{save_restart}{An integer vector of time points to save
restart information for; this is in addition to \code{save_state}
(which saves the final model state) and saves the full model
state.  It will use the same trajectory as \code{save_state} and
\code{save_trajectories}. Note that if you use this option you will
end up with lots of model states and will need to process them
in order to actually restart the pmcmc or the particle filter
from this state. The integers correspond to the \emph{time} variable
in your filter (see \link{particle_filter} for more
information).}

\item{save_trajectories}{Logical, indicating if the particle
trajectories should be saved during the simulation. If \code{TRUE},
then a single randomly selected particle's trajectory will be
collected at the end of each MCMC step.  This is the filtered
state (i.e., using the \code{state} component of \code{index} provided to
the particle filter).  If \code{save_state} is \code{TRUE} the same
particle will be selected for each.}

\item{progress}{Logical, indicating if a progress bar should be
displayed, using \code{\link[progress:progress_bar]{progress::progress_bar}}.}

\item{nested_step_ratio}{Either integer or 1/integer, which specifies the
ratio of fixed:varied steps in a nested pMCMC. For example \code{3} would run
3 steps proposing fixed parameters only and then 1 step proposing varied
parameters only; whereas \code{1/3} would run 3 varied steps
for every 1 fixed step. The default value of \code{1} runs an equal number of
iterations updating the fixed and varied parameters. Sensible choices
of this parameter may depend on the true ratio of fixed:varied parameters
or on desired run-time, for example updating fixed parameters is
quicker so more varied steps could be more efficient.}

\item{nested_update_both}{If \code{FALSE} (default) then alternates
between proposing fixed and varied parameter updates according
to the ratio in \code{nested_step_ratio}. If \code{TRUE} then proposes
fixed and varied parameters simultaneously and collectively
accepts/rejects them, \code{nested_step_ratio} is ignored.}

\item{filter_early_exit}{Logical, indicating if we should allow
the particle filter to exit early for points that will not be
accepted. Only use this if your log-likelihood never increases
between steps. This will the the case where your likelihood
calculation is a sum of discrete normalised probability
distributions, but may not be for continuous distributions!}

\item{restart_match}{Logical, indicating whether the restart state saved
from the particle filter should match the trajectory saved, otherwise
the restart state will be randomly drawn from the states of the particle
filter after filtering to the restart time point.}

\item{n_burnin}{Optionally, the number of points to discard as
burnin.  This happens separately to the burnin in
\link{pmcmc_thin} or \link{pmcmc_sample}.  See Details.}

\item{n_steps_retain}{Optionally, the number of samples to retain from
the \code{n_steps - n_burnin} steps.  See Details.}

\item{adaptive_proposal}{Optionally, control over an adaptive
proposal (\link{adaptive_proposal_control}). Alternatively
\code{FALSE} to disable, \code{TRUE} to enable defaults. This is only
valid for single-population deterministic models.}

\item{path}{Optional path to save partial pmcmc results in, when
using workers.  If not given (or \code{NULL}) then a temporary
directory is used.}
}
\value{
A \code{pmcmc_control} object, which should not be modified
once created.
}
\description{
Control for the pmcmc. This function constructs a list of options
and does some basic validation to ensure that the options will
work well together. Do not manually change the values in this
object. Do not refer to any argument except \code{n_steps} by position
as the order of the arguments may change in future.
}
\details{
pMCMC is slow and you will want to parallelise it if you possibly
can. There are two ways of doing this which are discussed in some
detail in \code{vignette("parallelisation", package = "mcstate")}.
}
\section{Thinning the chain at generation}{


Generally it may be preferable to thin the chains after generation
using \link{pmcmc_thin} or \link{pmcmc_sample}.
However, waiting that long can create memory consumption issues
because the size of the trajectories can be very large.  To
avoid this, you can thin the chains at generation - this will
avoid creating large trajectory arrays, but will discard some
information irretrivably.

If either of the options \code{n_burnin} or \code{n_steps_retain} are provided,
then we will subsample the chain at generation.
\itemize{
\item If \code{n_burnin} is provided, then the first \code{n_burnin} (of
\code{n_steps}) samples is discarded.  This must be at most \code{n_steps}
\item If \code{n_steps_retain} is provided, then we \emph{evenly} sample out of
the remaining samples.  The algorithm will try and generate a
sensible set here, and will always include the last sample of
\code{n_steps} but may not always include the first post-burnin
sample.  An error will be thrown if a suitable sampling is not
possible (e.g., if \code{n_steps_retain} is larger than \code{n_steps - n_burnin}
}

If either of \code{n_burnin} or \code{n_steps_retain} is provided, the
resulting samples object will include the full set of parameters
and probabilities sampled, along with an index showing how they
relate to the filtered samples.
}

\examples{
mcstate::pmcmc_control(1000)

# Suppose we have a fairly large node with 16 cores and we want to
# run 8 chains. We can use all cores for a single chain and run
# the chains sequentially like this:
mcstate::pmcmc_control(1000, n_chains = 8, n_threads_total = 16)

# However, on some platforms (e.g., Windows) this may only realise
# a 50\% total CPU use, in which case you might benefit from
# splitting these chains over different worker processes (2-4
# workers is likely the largest useful number).
mcstate::pmcmc_control(1000, n_chains = 8, n_threads_total = 16,
                       n_workers = 4)
}
