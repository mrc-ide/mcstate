% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmcmc_control.R
\name{pmcmc_control}
\alias{pmcmc_control}
\title{Control for the pmcmc}
\usage{
pmcmc_control(
  n_steps,
  n_chains = 1L,
  n_threads_total = NULL,
  n_workers = 1L,
  n_steps_each = NULL,
  rerun_every = Inf,
  rerun_random = FALSE,
  use_parallel_seed = FALSE,
  save_state = TRUE,
  save_restart = NULL,
  save_trajectories = FALSE,
  progress = FALSE,
  nested_step_ratio = 1
)
}
\arguments{
\item{n_steps}{Number of MCMC steps to run. This is the only
required argument.}

\item{n_chains}{Optional integer, indicating the number of chains
to run. If more than one then we run a series of chains and
merge them with \code{\link[=pmcmc_combine]{pmcmc_combine()}}. Chains are run in series,
with the same filter if \code{n_workers} is 1, or run in parallel
otherwise.}

\item{n_threads_total}{The total number of threads (i.e., cores)
the total number of threads/cores to use. If \code{n_workers} is
greater than 1 then these threads will be divided evenly across
your workers at first and so \code{n_threads_total} must be an even
multiple of \code{n_workers}. If chains finish at different times
(including if \code{n_chains} is not a multiple of \code{n_workers}) then
these threads/cores will be reallocated across workers that are
still going. If \code{n_workers} is 1 (i.e., running in parallel) and
\code{n_threads_total} is not given (i.e., \code{NULL}) we will use the
number of threads specified in the particle filter
creation. Otherwise this value overrides the value in the
particle filter.}

\item{n_workers}{Number of "worker" processes to use to run chains
in parallel. This must be at most \code{n_chains} and is recommended
to be a divisor of \code{n_chains}. If \code{n_workers} is 1, then chains
are run in series (i.e., one chain after the other). See the
parallel vignette (\code{vignette("parallelisation", package = "mcstate")}) for more details about this approach.}

\item{n_steps_each}{If using workers (i.e., \code{n_workers > 1}), the
number of steps to run in each "chunk" on each worker before
reporting back to the main process. Increasing this will make
progress reporting less frequent and reduce some communication
overhead (though the overhead is likely to be trivial in any
real application). Decreasing this will give more frequent
process reporting and if \code{n_threads_total} is given will allow
for more rapid re-allocation of unused cores once chains start
finishing. The default, if not given and if \code{n_workers > 1} is
to use 10\% of \code{n_steps}.}

\item{rerun_every}{Optional integer giving the frequency at which
we should rerun the particle filter on the current "accepted"
state.  The default for this (\code{Inf}) will never rerun this
point, but if you set to 100, then every 100 steps we run the
particle filter on both the proposed \emph{and} previously accepted
point before doing the comparison.  This may help "unstick"
chains, at the cost of some bias in the results.}

\item{rerun_random}{Logical, indicating if \code{rerun_every}
should be interpreted as exactly every \code{rerun_every} steps (if
\code{FALSE}) or on average (if \code{TRUE}). If \code{TRUE}, then we rerun
every step with probability \code{1 / rerun_every}.}

\item{use_parallel_seed}{Logical, indicating if seeds should be
configured in the same way as when running workers in parallel
(with \code{n_workers > 1}).  Set this to \code{TRUE} to ensure
reproducibility if you use this option sometimes (but not
always). This option only has an effect if \code{n_workers} is 1.}

\item{save_state}{Logical, indicating if the state should be saved
at the end of the simulation. If \code{TRUE}, then a single
randomly selected particle's state will be collected at the end
of each MCMC step. This is the full state (i.e., unaffected by
and \code{index} used in the particle filter) so that the
process may be restarted from this point for projections.  If
\code{save_trajectories} is \code{TRUE} the same particle will
be selected for each. The default is \code{TRUE}, which will
cause \code{n_state} * \code{n_steps} of data to be output
alongside your results. Set this argument to \code{FALSE} to
save space, or use \code{\link[=pmcmc_thin]{pmcmc_thin()}} after running the
MCMC.}

\item{save_restart}{An integer vector of time points to save
restart information for; this is in addition to \code{save_state}
(which saves the final model state) and saves the full model
state.  It will use the same trajectory as \code{save_state} and
\code{save_trajectories}. Note that if you use this option you will
end up with lots of model states and will need to process them
in order to actually restart the pmcmc or the particle filter
from this state. The integers correspond to the \emph{time} variable
in your filter (see \link{particle_filter} for more
information).}

\item{save_trajectories}{Logical, indicating if the particle
trajectories should be saved during the simulation. If \code{TRUE},
then a single randomly selected particle's trajectory will be
collected at the end of each MCMC step.  This is the filtered
state (i.e., using the \code{state} component of \code{index} provided to
the particle filter).  If \code{save_state} is \code{TRUE} the same
particle will be selected for each.}

\item{progress}{Logical, indicating if a progress bar should be
displayed, using \code{\link[progress:progress_bar]{progress::progress_bar}}.}

\item{nested_step_ratio}{Either integer or 1/integer, which specifies the
ratio of fixed:varied steps in a nested pMCMC. For example \code{3} would run
3 steps proposing fixed parameters only and then 1 step proposing varied
parameters only; whereas \code{1/3} would run 3 varied steps
for every 1 fixed step. The default value of \code{1} runs an equal number of
iterations updating the fixed and varied parameters. Sensible choices
of this parameter may depend on the true ratio of fixed:varied parameters
or on desired run-time, for example updating fixed parameters is
quicker so more varied steps could be more efficient.}
}
\value{
A \code{pmcmc_control} object, which should not be modified
once created.
}
\description{
Control for the pmcmc. This function constructs a list of options
and does some basic validation to ensure that the options will
work well together. Do not manually change the values in this
object. Do not refer to any argument except \code{n_steps} by position
as the order of the arguments may change in future.
}
\details{
pMCMC is slow and you will want to parallelise it if you possibly
can. There are two ways of doing this which are discussed in some
detail in \code{vignette("parallelisation", package = "mcstate")}.
}
\examples{
mcstate::pmcmc_control(1000)

# Suppose we have a fairly large node with 16 cores and we want to
# run 8 chains. We can use all cores for a single chain and run
# the chains sequentially like this:
mcstate::pmcmc_control(1000, n_chains = 8, n_threads_total = 16)

# However, on some platforms (e.g., Windows) this may only realise
# a 50\% total CPU use, in which case you might benefit from
# splitting these chains over different worker processes (2-4
# workers is likely the largest useful number).
mcstate::pmcmc_control(1000, n_chains = 8, n_threads_total = 16,
                       n_workers = 4)
}
