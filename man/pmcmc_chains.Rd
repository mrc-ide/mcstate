% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmcmc_chains.R
\name{pmcmc_chains_prepare}
\alias{pmcmc_chains_prepare}
\alias{pmcmc_chains_run}
\alias{pmcmc_chains_collect}
\alias{pmcmc_chains_cleanup}
\title{pMCMC with manual chain scheduling}
\usage{
pmcmc_chains_prepare(path, pars, filter, control, initial = NULL)

pmcmc_chains_run(chain_id, path, n_threads = NULL)

pmcmc_chains_collect(path)

pmcmc_chains_cleanup(path)
}
\arguments{
\item{path}{The path to use to exchange inputs and results.  You
can use a temporary directory or a different path (relative or
absolute).  Several rds files will be created.  It is strongly
recommended not to use \code{.}}

\item{pars}{A \code{\link{pmcmc_parameters}} object containing
information about parameters (ranges, priors, proposal kernel,
translation functions for use with the particle filter).}

\item{filter}{A \code{\link{particle_filter}} object}

\item{control}{A \link{pmcmc_control} object which will
control how the MCMC runs, including the number of steps etc.}

\item{initial}{Optional initial starting point. If given, it must
be compatible with the parameters given in \code{pars}, and must be
valid against your prior. You can use this to override the
initial conditions saved in your \code{pars} object. You can provide
either a vector of initial conditions, or a matrix with
\code{n_chains} columns to use a different starting point for each
chain.}

\item{chain_id}{The integer identifier of the chain to run}

\item{n_threads}{Optional thread count, overriding the number set
in the \code{control}.  This will be useful where preparing the
threads on a machine with one level of resource and running it
on another.}
}
\description{
Run a pMCMC, with sensible random number behaviour, but schedule
execution of the chains yourself. Use this if you want to
distribute chains over (say) the nodes of an HPC system.
}
\details{
Basic usage will look like

\if{html}{\out{<div class="sourceCode">}}\preformatted{path <- mcstate::pmcmc_chains_prepare(tempfile(), pars, filter, control)
for (i in seq_len(control$n_chains)) \{
  mcstate::pmcmc_chains_run(i, path)
\}
samples <- mcstate::pmcmc_chains_collect(path)
mcstate::pmcmc_chains_cleanup(path)
}\if{html}{\out{</div>}}

You can safely parallelise (or not) however you like at the point
where the loop is (even across other machines) and get the same
outputs regardless.
}
