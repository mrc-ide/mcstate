% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmcmc_parameters.R
\name{pmcmc_parameters}
\alias{pmcmc_parameters}
\title{pmcmc_parameters}
\description{
Construct parameters for use with
\code{\link[=pmcmc]{pmcmc()}}. This creates a utility object that is used
internally to work with parameters. Most users only need to
construct this object, but see the examples for how it can be
used.
}
\section{Parameter transformations}{


Unless you have a very simple model, it is highly unlikely that
the parameters that you are interested in performing inference
on are the same as the parameters that you might need to
initialise your model.

Due to the nature of mcmc and other inference algorithms, the
general assumption is that the inference parameters will be a
simple vector of real values; here each of the \code{parameters}
elements corresponds to one of these. The proposal matrix maps
one vector to another via a simple multivariate-gaussian kernel.

On the other hand, dust models can take a named list of arbitrary
data as their input parameters (see
\link[dust:dust_generator]{dust::dust_generator}). These might include:
\itemize{
\item things that are not parameters at all from the perspective of
the inference - for example some quantity that you might vary
depending on the region/species/etc you're running the model for
but that you are not fitting.
\item non-scalar quantities that are directly derived from some
parameters that you are fitting.  As an example of this, in
\href{https://mrc-ide.github.io}{sircovid}, a transmission model of
COVID, we take a number of "contact rates" which apply at
different points in time, and generate from this an interpolated
series of contact rates per time step (a very long
vector). Other users have needed to generate equilibrium
solutions to parts of their model and used these at
initialisation.
\item arbitrary complex inputs to the model, for example weather data,
demographic matrices, population contact rate matrices
etc. These are all "parameters" from the perspective of a dust
model but not at all from the perspective of the inference
process.
}

To allow for this in a flexible way, mcstate allows a "transform"
function, the \code{transform} argument to the constructor. This
function maps a named numeric ector of inference parameters to
whatever you need for your dust model.  The default value for
this function is \link{as.list} which just converts the named vector
to a named list, which works well in the example cases here.

When providing a transformation function, you may want to provide
a "closure" rather than a top-level function. This way you can
bind additional data into your function.  For example, suppose
that you want to use some demographic matrix \code{m} in your model,
and perform inference on parameters \code{a} and \code{b} you might write

\if{html}{\out{<div class="sourceCode">}}\preformatted{make_transform <- function(m) \{
  function(theta) \{
    c(list(m = m), as.list(theta))
  \}
\}
}\if{html}{\out{</div>}}

and pass this into \code{mcstate::pmcmc_parameters$new}, providing
parameter definitions only for \code{a} and \code{b}.  See the examples
for full working of this.
}

\examples{
# Construct an object with two parameters:
pars <- mcstate::pmcmc_parameters$new(
  list(mcstate::pmcmc_parameter("a", 0.1, min = 0, max = 1,
                                prior = function(a) log(a)),
       mcstate::pmcmc_parameter("b", 0, prior = dnorm)),
  matrix(c(1, 0.5, 0.5, 2), 2, 2))

# Initial parameters
p <- pars$initial()
p

# Propose a new parameter point
pars$propose(p)

# Information about parameters:
pars$names()
pars$summary()

# Compute prior
pars$prior(p)

# Transform data for your model
pars$model(p)

# Above we describe a nontrivial transformation function using a closure
make_transform <- function(m) {
  function(theta) {
    c(list(m = m), as.list(theta))
  }
}

# Suppose this is our demographic matrix (note here that the name
# need not match that used in the transform)
demographic_matrix <- diag(4)

# Construct the parameters as above, but this time passing in the
# function that make_transform returns
pars <- mcstate::pmcmc_parameters$new(
  list(mcstate::pmcmc_parameter("a", 0.1, min = 0, max = 1,
                                prior = function(a) log(a)),
       mcstate::pmcmc_parameter("b", 0, prior = dnorm)),
  matrix(c(1, 0.5, 0.5, 2), 2, 2),
  make_transform(m))

# Now, as above we start from a position in terms of a and b only:
pars$initial()

# But when prepared for the model, our matrix will be set up
pars$model(pars$initial())
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-pmcmc_parameters-new}{\code{pmcmc_parameters$new()}}
\item \href{#method-pmcmc_parameters-initial}{\code{pmcmc_parameters$initial()}}
\item \href{#method-pmcmc_parameters-mean}{\code{pmcmc_parameters$mean()}}
\item \href{#method-pmcmc_parameters-vcv}{\code{pmcmc_parameters$vcv()}}
\item \href{#method-pmcmc_parameters-names}{\code{pmcmc_parameters$names()}}
\item \href{#method-pmcmc_parameters-summary}{\code{pmcmc_parameters$summary()}}
\item \href{#method-pmcmc_parameters-prior}{\code{pmcmc_parameters$prior()}}
\item \href{#method-pmcmc_parameters-propose}{\code{pmcmc_parameters$propose()}}
\item \href{#method-pmcmc_parameters-model}{\code{pmcmc_parameters$model()}}
\item \href{#method-pmcmc_parameters-fix}{\code{pmcmc_parameters$fix()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-new"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-new}{}}}
\subsection{Method \code{new()}}{
Create the pmcmc_parameters object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$new(parameters, proposal, transform = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{parameters}}{A \code{list} of
\link{pmcmc_parameter} objects, each of which describe a
single parameter in your model. If \code{parameters} is named, then
these names must match the \verb{$name} element of each parameter is
used (this is verified).}

\item{\code{proposal}}{A square proposal distribution corresponding to the
variance-covariance matrix of a multivariate gaussian distribution
used to generate new parameters. It must have the same number of
rows and columns as there are elements in \code{parameters}, and if
named the names must correspond exactly to the names in
\code{parameters}. Because it corresponds to a variance-covariance
matrix it must be symmetric and positive definite.}

\item{\code{transform}}{An optional transformation function to apply
to your parameter vector immediately before passing it to the
model function. If not given, then \link{as.list} is
used, as dust models require this. However, if t you need to
generate derived parameters from those being actively sampled
you can do arbitrary transformations here.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-initial"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-initial}{}}}
\subsection{Method \code{initial()}}{
Return the initial parameter values as a named numeric
vector
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$initial()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-mean"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-mean}{}}}
\subsection{Method \code{mean()}}{
Return the estimate of the mean of the parameters,
as set when created (this is not updated by any fitting!)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$mean()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-vcv"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-vcv}{}}}
\subsection{Method \code{vcv()}}{
Return the variance-covariance matrix used for the
proposal.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$vcv()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-names"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-names}{}}}
\subsection{Method \code{names()}}{
Return the names of the parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$names()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-summary"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-summary}{}}}
\subsection{Method \code{summary()}}{
Return a \code{data.frame} with information about
parameters (name, min, max, and integer).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$summary()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-prior"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-prior}{}}}
\subsection{Method \code{prior()}}{
Compute the prior for a parameter vector
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$prior(theta)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta}}{a parameter vector in the same order as your
parameters were defined in (see \verb{$names()} for that order.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-propose"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-propose}{}}}
\subsection{Method \code{propose()}}{
Propose a new parameter vector given a current parameter
vector. This proposes a new parameter vector given your current
vector and the variance-covariance matrix of your proposal
kernel, rounds any integer values, and reflects bounded
parameters until they lie within \code{min}:\code{max}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$propose(theta, scale = 1, vcv = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta}}{a parameter vector in the same order as your
parameters were defined in (see \verb{$names()} for that order.}

\item{\code{scale}}{an optional scaling factor to apply to the
proposal distribution. This may be useful in sampling starting
points. The parameter is equivalent to a multiplicative factor
applied to the variance covariance matrix.}

\item{\code{vcv}}{A variance covariance matrix of the correct size,
overriding the proposal matrix built into the parameters object.
This will be slightly less efficient but allow a different proposal
matrix to be used (e.g., during an adaptive MCMC)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-model"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-model}{}}}
\subsection{Method \code{model()}}{
Apply the model transformation function to a parameter
vector.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$model(theta)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta}}{a parameter vector in the same order as your
parameters were defined in (see \verb{$names()} for that order.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pmcmc_parameters-fix"></a>}}
\if{latex}{\out{\hypertarget{method-pmcmc_parameters-fix}{}}}
\subsection{Method \code{fix()}}{
Set some parameters to fixed values. Use this to
reduce the dimensionality of your system.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pmcmc_parameters$fix(fixed)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fixed}}{a named vector of parameters to fix}
}
\if{html}{\out{</div>}}
}
}
}
