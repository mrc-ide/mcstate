% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmcmc.R
\name{pmcmc_chains_prepare}
\alias{pmcmc_chains_prepare}
\alias{pmcmc_chains_run}
\title{pMCMC with manual chain scheduling}
\usage{
pmcmc_chains_prepare(pars, filter, initial = NULL, control = NULL)

pmcmc_chains_run(chain_id, inputs, path = NULL)
}
\arguments{
\item{pars}{A \code{\link{pmcmc_parameters}} object containing
information about parameters (ranges, priors, proposal kernel,
translation functions for use with the particle filter).}

\item{filter}{A \code{\link{particle_filter}} object}

\item{initial}{Optional initial starting point. If given, it must
be compatible with the parameters given in \code{pars}, and must be
valid against your prior. You can use this to override the
initial conditions saved in your \code{pars} object. You can provide
either a vector of initial conditions, or a matrix with
\code{n_chains} columns to use a different starting point for each
chain.}

\item{control}{A \link{pmcmc_control} object which will set
parameters. This will become the primary way of specifying
options very soon and it is an error if you use both \code{control}
and any of the parameters above aside from \code{pars} and \code{filter}.}

\item{chain_id}{The chain index to run (1, 2, ..., \code{control$n_chains})}

\item{inputs}{A \code{pmcmc_inputs} object created by \code{pmcmc_chains_prepare}}

\item{path}{Optionally a directory to save output in. This might
be useful if splitting work across multiple processes. Samples
will be saved at \verb{<path>/samples_<chain_id>.rds}}
}
\description{
Run a pMCMC, with sensible random number behaviour, but schedule
execution of the chains yourself. Use this if you want to
distribute chains over (say) the nodes of an HPC system.
}
\details{
Basic usage will look like\preformatted{inputs <- mcstate::pmcmc_chains_prepare(pars, filter, control = control)
samples_data <-
  lapply(seq_len(control$n_chains), mcstate::pmcmc_chains_run, inputs)
samples <- mcstate::pmcmc_combine(samples = samples)
}

You can safely parallelise (or not) however you like at the
\code{lapply} call and get the same outputs regardless.
}
